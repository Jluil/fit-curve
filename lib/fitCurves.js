// Generated by CoffeeScript 1.9.3
(function() {
  " CoffeeScript implementation of\nAlgorithm for Automatically Fitting Digitized Curves\nby Philip J. Schneider\n\"Graphics Gems\", Academic Press, 1990";
  var add, bezier, chain, chordLengthParameterize, computeMaxError, dot, fitCubic, fitCurve, generateBezier, last, lodash, math, multiply, newtonRaphsonRootFind, normalize, reparameterize, subtract, zeros, zip;

  math = (typeof require === "function" ? require('mathjs') : void 0) || (typeof window !== "undefined" && window !== null ? window.mathjs : void 0);

  lodash = (typeof require === "function" ? require('lodash') : void 0) || (typeof window !== "undefined" && window !== null ? window._ : void 0);

  zeros = math.zeros;

  multiply = math.multiply;

  subtract = math.subtract;

  add = math.add;

  chain = math.chain;

  dot = math.dot;

  last = lodash.last;

  zip = lodash.zip;

  bezier = {
    q: function(ctrlPoly, t) {
      return math.chain(multiply(Math.pow(1.0 - t, 3), ctrlPoly[0])).add(multiply(3 * Math.pow(1.0 - t, 2) * t, ctrlPoly[1])).add(multiply(3 * (1.0 - t) * Math.pow(t, 2), ctrlPoly[2])).add(multiply(Math.pow(t, 3), ctrlPoly[3])).done();
    },
    qprime: function(ctrlPoly, t) {
      return math.chain(multiply(3 * Math.pow(1.0 - t, 2), subtract(ctrlPoly[1], ctrlPoly[0]))).add(multiply(6 * (1.0 - t) * t, subtract(ctrlPoly[2], ctrlPoly[1]))).add(multiply(3 * Math.pow(t, 2), subtract(ctrlPoly[3], ctrlPoly[2]))).done();
    },
    qprimeprime: function(ctrlPoly, t) {
      return add(multiply(6 * (1.0 - t), add(subtract(ctrlPoly[2], multiply(2, ctrlPoly[1])), ctrlPoly[0])), multiply(6 * t, add(subtract(ctrlPoly[3], multiply(2, ctrlPoly[2])), ctrlPoly[1])));
    }
  };

  fitCurve = function(points, maxError) {
    var leftTangent, rightTangent;
    leftTangent = normalize(subtract(points[1], points[0]));
    rightTangent = normalize(subtract(points[points.length - 2], last(points)));
    return fitCubic(points, leftTangent, rightTangent, maxError);
  };

  fitCubic = function(points, leftTangent, rightTangent, error) {
    var bezCurve, beziers, centerTangent, dist, i, j, maxError, ref, ref1, splitPoint, u, uPrime;
    if (points.length === 2) {
      dist = math.norm(subtract(points[0], points[1])) / 3.0;
      bezCurve = [points[0], add(points[0], multiply(leftTangent, dist)), add(points[1], multiply(rightTangent, dist)), points[1]];
      return [bezCurve];
    }
    u = chordLengthParameterize(points);
    bezCurve = generateBezier(points, u, leftTangent, rightTangent);
    ref = computeMaxError(points, bezCurve, u), maxError = ref[0], splitPoint = ref[1];
    if (maxError < error) {
      return [bezCurve];
    }
    if (maxError < Math.pow(error, 2)) {
      for (i = j = 0; j < 20; i = ++j) {
        uPrime = reparameterize(bezCurve, points, u);
        bezCurve = generateBezier(points, uPrime, leftTangent, rightTangent);
        ref1 = computeMaxError(points, bezCurve, uPrime), maxError = ref1[0], splitPoint = ref1[1];
        if (maxError < error) {
          return [bezCurve];
        }
        u = uPrime;
      }
    }
    beziers = [];
    centerTangent = normalize(subtract(points[splitPoint - 1], points[splitPoint + 1]));
    beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, centerTangent, error));
    beziers = beziers.concat(fitCubic(points.slice(splitPoint), multiply(centerTangent, -1), rightTangent, error));
    return beziers;
  };

  generateBezier = function(points, parameters, leftTangent, rightTangent) {
    var A, C, X, alpha_l, alpha_r, bezCurve, det_C0_C1, det_C0_X, det_X_C1, epsilon, i, j, k, len, len1, point, ref, ref1, segLength, tmp, u;
    bezCurve = [points[0], null, null, last(points)];
    A = zeros(parameters.length, 2, 2).valueOf();
    for (i = j = 0, len = parameters.length; j < len; i = ++j) {
      u = parameters[i];
      A[i][0] = multiply(leftTangent, 3 * Math.pow(1 - u, 2) * u);
      A[i][1] = multiply(rightTangent, 3 * (1 - u) * Math.pow(u, 2));
    }
    C = zeros(2, 2).valueOf();
    X = zeros(2).valueOf();
    ref = zip(points, parameters);
    for (i = k = 0, len1 = ref.length; k < len1; i = ++k) {
      ref1 = ref[i], point = ref1[0], u = ref1[1];
      C[0][0] += dot(A[i][0], A[i][0]);
      C[0][1] += dot(A[i][0], A[i][1]);
      C[1][0] += dot(A[i][0], A[i][1]);
      C[1][1] += dot(A[i][1], A[i][1]);
      tmp = subtract(point, bezier.q([points[0], points[0], last(points), last(points)], u));
      X[0] += dot(A[i][0], tmp);
      X[1] += dot(A[i][1], tmp);
    }
    det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
    det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];
    det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];
    alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
    alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
    segLength = math.norm(subtract(points[0], last(points)));
    epsilon = 1.0e-6 * segLength;
    if (alpha_l < epsilon || alpha_r < epsilon) {
      bezCurve[1] = add(bezCurve[0], multiply(leftTangent, segLength / 3.0));
      bezCurve[2] = add(bezCurve[3], multiply(rightTangent, segLength / 3.0));
    } else {
      bezCurve[1] = add(bezCurve[0], multiply(leftTangent, alpha_l));
      bezCurve[2] = add(bezCurve[3], multiply(rightTangent, alpha_r));
    }
    return bezCurve;
  };

  reparameterize = function(bezier, points, parameters) {
    var j, len, point, ref, ref1, results, u;
    ref = zip(points, parameters);
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      ref1 = ref[j], point = ref1[0], u = ref1[1];
      results.push(newtonRaphsonRootFind(bezier, point, u));
    }
    return results;
  };

  newtonRaphsonRootFind = function(bez, point, u) {
    "Newton's root finding algorithm calculates f(x)=0 by reiterating\nx_n+1 = x_n - f(x_n)/f'(x_n)\nWe are trying to find curve parameter u for some point p that minimizes\nthe distance from that point to the curve. Distance point to curve is d=q(u)-p.\nAt minimum distance the point is perpendicular to the curve.\nWe are solving\nf = q(u)-p * q'(u) = 0\nwith\nf' = q'(u) * q'(u) + q(u)-p * q''(u)\ngives\nu_n+1 = u_n - |q(u_n)-p * q'(u_n)| / |q'(u_n)**2 + q(u_n)-p * q''(u_n)|";
    var d, denominator, numerator, qprime;
    d = subtract(bezier.q(bez, u), point);
    qprime = bezier.qprime(bez, u);
    numerator = math.sum(multiply(d, qprime));
    denominator = math.sum(add(math.dotPow(qprime, 2), multiply(d, bezier.qprimeprime(bez, u))));
    if (denominator === 0) {
      return u;
    } else {
      return u - numerator / denominator;
    }
  };

  chordLengthParameterize = function(points) {
    var i, j, k, ref, ref1, u;
    u = [0];
    for (i = j = 1, ref = points.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
      u.push(u[i - 1] + math.norm(subtract(points[i], points[i - 1])));
    }
    for (i = k = 0, ref1 = u.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
      u[i] = u[i] / last(u);
    }
    return u;
  };

  computeMaxError = function(points, bez, parameters) {
    var dist, i, j, len, maxDist, point, ref, ref1, splitPoint, u;
    maxDist = 0;
    splitPoint = points.length / 2;
    ref = zip(points, parameters);
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      ref1 = ref[i], point = ref1[0], u = ref1[1];
      dist = Math.pow(math.norm(subtract(bezier.q(bez, u), point)), 2);
      if (dist > maxDist) {
        maxDist = dist;
        splitPoint = i;
      }
    }
    return [maxDist, splitPoint];
  };

  normalize = function(v) {
    return math.divide(v, math.norm(v));
  };

  if (typeof exports !== "undefined" && exports !== null) {
    if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
      module.exports = fitCurve;
    } else {
      exports.fitCurve = fitCurve;
    }
  } else if (window) {
    window.fitCurve = fitCurve;
  }

}).call(this);
